\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{array}
\usetikzlibrary{trees}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{multirow} 
\usepackage{dcolumn}
\usepackage{verbatim}

\newcolumntype{2}{D{.}{}{2.0}}

\title{CSC282 HW2}
\author{Hanzhang Yin}
\date{Sep/16/2023}

\begin{document}

\maketitle

\section*{Question 6}


\begin{comment}
# Helper Function
function CCW(p1, p2, p3):
    #True if counter-clockwise turn
    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0  

function sortPointsLexicographically(points):
    # Sort the points by x-coordinate, breaking ties with y-coordinate
    # Time-complexity O(n log n)
    return sorted(points, key: (point.x, point.y))

# Main Function (Andrew's Algorithm)
function constructSimplePolygon(points):
    # Sort points lexicographically
    sortedPoints = sortPointsLexicographically(points)

    # Build the upper chain
    upperChain = []
    for point in sortedPoints:
        upperChain.append(point)
        while len(upperChain) >= 3 and not CCW_left(upperChain[len(upperChain) - 3],
                                                    upperChain[len(upperChain) - 2],
                                                    upperChain[len(upperChain) - 1]):
            # Remove the middle point to maintain the CCW property
            upperChain.pop(len(upperChain) - 2)

    # Build the lower chain
    lowerChain = []
    for point in reverse(sortedPoints):
        lowerChain.append(point)
        while len(lowerChain) >= 3 and not CCW_left(lowerChain[len(lowerChain) - 3],
                                                    lowerChain[len(lowerChain) - 2],
                                                    lowerChain[len(lowerChain) - 1]):
            # Remove the middle point to maintain the CCW property
            lowerChain.pop(len(lowerChain) - 2)

    # Combine the chains to form the simple polygon
    upperChain.pop(len(upperChain) - 1)
    lowerChain.pop(len(lowerChain) - 1)
    polygon = upperChain + lowerChain

    # Return the polygon containing all points
    return polygon
\end{comment}

\begin{verbatim}
# Helper Functions
def CCW(p1, p2, p3):
    return (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x) > 0

def polarAngle(p0, p1):
    # Compute the polar angle from p0 to p1
    return math.atan2(p1.y - p0.y, p1.x - p0.x)

def distanceSquared(p0, p1):
    return (p1.x - p0.x)**2 + (p1.y - p0.y)**2

def sortPointsByPolarAngle(points, p0):
    # Sort the points by polar angle with p0, breaking ties by distance
    return sorted(points, key = (polarAngle(p0, p), -distanceSquared(p0, p)))

# Main Function (Graham's Algorithm)
def constructSimplePolygon(points):
    # Find the point with the lowest y-coordinate, break ties with x-coordinate
    # Time-complexity O(n)
    p0 = min(points, key = (p.y, p.x))

    points_except_p0 = [p for p in points if p != p0]

    # Sort the points by polar angle with p0
    # Time-complexity O(n log n)
    sortedPoints = sortPointsByPolarAngle(points_except_p0, p0)

    # Initialize the convex hull with point p0

    # Time-complexity O(n)
    for point in sortedPoints:
        hull.append(point)
        while len(hull) >= 3 and !CCW(hull[len(hull) - 3], 
            hull[len(hull) - 2], hull[len(hull) - 1]):
            # Remove the middle point to maintain the CCW property
            hull.pop(len(hull) - 2)

    return hull
\end{verbatim}

\newpage

\section*{Question 7}

\begin{verbatim}
function findVisibleSegments(segments, p):

    # Collect all events (segment endpoints) and compute their angles from point p
    # Time Complexity: O(n)
    events = []
    for segment in segments:
        angleStart = computeAngle(p, segment.start)
        angleEnd = computeAngle(p, segment.end)

        # Normalize angles to [0, 2pi)
        angleStart = normalizeAngle(angleStart)
        angleEnd = normalizeAngle(angleEnd)

        if angleStart <= angleEnd:
            events.append({'angle': angleStart, 'segment': segment, 
                type': 'start'})
            events.append({'angle': angleEnd, 'segment': segment, 
                    'type': 'end'})
        else:
            # Segment crosses the 0 angle
            events.append({'angle': angleStart, 'segment': segment, 
                'type': 'start'})
            events.append({'angle': angleEnd + 2 * PI, 'segment': segment, 
                'type': 'end'})

    # Sort all events by angle
    # Time Complexity: O(n log n)
    sortedEvents = sortByAngle(events)

    # The BST is ordered by distance from p along the current angle
    activeSegments = emptyBST()

    visibleSegments = emptySet()

    # Sweep through all sorted events to determine visibility
    # Time Complexity: O(n log n)
    for event in sortedEvents:
        angle = event['angle'] % (2 * PI)  # Normalize angle within [0, 2pi)
        segment = event['segment']

        if event['type'] == 'start':
            # Compute the distance from p to the segment along the current angle
            distance = computeDistanceToSegment(p, angle, segment)
            
            # Insert the segment into the activeSegments
                BST with the computed distance
            insertSegment(activeSegments, segment, distance)
            
            # Check if this segment is the closest one currently
            closestSegment = activeSegments.findMin()
            if closestSegment == segment:
                # If it's the closest, add to visibleSegments
                visibleSegments.add(segment)
        elif event['type'] == 'end':
            # Remove the segment from the activeSegments BST
            removeSegment(activeSegments, segment)
            
            # After removal, check the new closest segment
            closestSegment = activeSegments.findMin()
            if closestSegment is not None:
                visibleSegments.add(closestSegment)

    return visibleSegments
\end{verbatim}

\newpage

\section*{Question 8}
The following code addressed the problem: counting intersections of axis-aligned segments in $O(n log n)$ time. Note that the codec is implemented in \textit{Python}.
\\
The algorithm uses a sweep-line technique combined with a Binary Indexed Tree (BIT) to achieve this time complexity.
Segments are represented with endpoints and classified as horizontal or vertical; y-coordinates are compressed into integer indices for efficient BIT operations. 
Events are created: horizontal segments generate add and remove events at their x-endpoints, while vertical segments generate query events at their x-coordinate. 
Events are sorted by x-coordinate, processing adds before queries and queries before removes when x-values are equal. 
As the sweep line advances, the BIT maintains the active set of horizontal segments' y-indices. 
During query events, the BIT efficiently counts active horizontal segments overlapping the vertical segment's y-range.
Noticing that BIT costs \( O(\log n) \) time updates and queries. Hence, the sweep line framework achieves the \( O(n \log n) \) time complexity.

\begin{verbatim}
# Axis-Aligned Segment Intersection Counting Algorithm
# Time Complexity: O(n log n)

class Segment:
    def __init__(self, x1, y1, x2, y2):
        # Ensure (x1, y1) is the lower-left point and (x2, y2) is the upper-right point
        if x1 > x2 or y1 > y2:
            x1, x2 = min(x1, x2), max(x1, x2)
            y1, y2 = min(y1, y2), max(y1, y2)
        self.x1, self.y1 = x1, y1
        self.x2, self.y2 = x2, y2
        # Determine if the segment is horizontal or vertical
        self.is_horizontal = y1 == y2
        self.is_vertical = x1 == x2

def coordinate_compress(coordinates):
    unique_coords = sorted(set(coordinates))
    coord_dict = {coord: idx for idx, coord in enumerate(unique_coords)}
    return coord_dict

# Define Binary Indexed Tree
class BIT:
    def __init__(self, size):
        self.size = size + 2  # +2 to avoid indexing error
        self.tree = [0] * self.size

    def update(self, idx, val):
        idx += 1  # BIT uses 1-based indexing
        while idx < self.size:
            self.tree[idx] += val
            idx += idx & -idx

    def query(self, idx):
        idx += 1
        result = 0
        while idx > 0:
            result += self.tree[idx]
            idx -= idx & -idx
        return result

    def range_query(self, l, r):
        return self.query(r) - self.query(l - 1)

def count_intersections(segments):
    horizontal_segments = []
    vertical_segments = []
    y_coords = []

    for seg in segments:
        if seg.is_horizontal:
            horizontal_segments.append(seg)
            y_coords.append(seg.y1)
        elif seg.is_vertical:
            vertical_segments.append(seg)
            y_coords.append(seg.y1)
            y_coords.append(seg.y2)

    # Coordinate compression for y-coordinates
    y_coord_map = coordinate_compress(y_coords)
    max_y_idx = len(y_coord_map)

    events = []

    # Create add and remove events for horizontal segments
    for seg in horizontal_segments:
        y_idx = y_coord_map[seg.y1]
        events.append((seg.x1, 0, y_idx))  # Add event
        events.append((seg.x2, 2, y_idx))  # Remove event

    # Create query events for vertical segments
    for seg in vertical_segments:
        y1_idx = y_coord_map[seg.y1]
        y2_idx = y_coord_map[seg.y2]
        events.append((seg.x1, 1, min(y1_idx, y2_idx), max(y1_idx, y2_idx)))

    # Sort events by x-coordinate and event type
    events.sort(key=lambda x: (x[0], x[1]))

    bit = BIT(max_y_idx)
    intersection_count = 0

    for event in events:
        if event[1] == 0:
            # Add event: add horizontal segment's y-coordinate to BIT
            y_idx = event[2]
            bit.update(y_idx, 1)
        elif event[1] == 2:
            # Remove event: remove horizontal segment's y-coordinate from BIT
            y_idx = event[2]
            bit.update(y_idx, -1)
        else:
            # Query event: count overlapping horizontal segments
            y1_idx, y2_idx = event[2], event[3]
            count = bit.range_query(y1_idx, y2_idx)
            intersection_count += count

    return intersection_count
\end{verbatim}

\newpage

\section*{Question 9}
Picked Probelm: \textbf{Simple Linear-Time Polygon Triangulation} 
\\
\url{https://topp.openproblem.net/p10#AGR00}

\subsection*{Problem Description:}
Polygon triangulation involves partitioning a simple polygon into non-overlapping triangles.
The primary challenge lies in achieving efficient algorithms that perform this triangulation in linear time, especially for large and complex polygons.

\subsection*{Approaches and Recent Developments:}
Chazelle's [1] groundbreaking 1991 algorithm was the first to achieve deterministic linear-time triangulation of a simple polygon. However, its complexity has driven researchers to seek simpler yet efficient alternatives. Recent (But not that recent) advancements include both deterministic and randomized algorithms that strive to match or approach linear-time performance with greater simplicity:
\begin{enumerate}
    \item \textbf{Deterministic Linear-Time Algorithm: }
    A new approach leverages the polygon-cutting and planar separator theorems to build a coarse triangulation in a bottom-up phase, followed by a top-down refinement [2]. This method avoids complex data structures like dynamic search trees, relying instead on elementary structures, thus simplifying implementation compared to Chazelle's algorithm.
    \item \textbf{Randomized Algorithms: }
    One algorithm computes the trapezoidal decomposition of a simple polygon in expected linear time, enabling linear-time triangulation through known reductions. It simplifies Chazelle's method by performing random sampling  [3] on subchains of the polygon rather than its edges.
    \\
    *Another incremental randomized algorithm achieves expected $O(nlog*n)$ time for trapezoidal decompositions and triangulation, utilizing basic probabilistic techniques without intricate data structures.
\end{enumerate}

\subsection*{Wrap Up:}
Randomized algorithms have provided more straightforward methods for efficient polygon triangulation, achieving linear time performance. However, the development of a deterministic linear-time algorithm that is significantly simpler than Chazelle's remains an open challenge.


\begin{thebibliography}{3}
    \bibitem{Cha91}
    Chazelle, Bernard. 1991. “Triangulating a Simple Polygon in Linear Time.” \textit{Discrete \& Computational Geometry}, 6(3): 485-524. https://doi.org/10.1007/BF02574703.

    \bibitem{Amato2000}
    Amato, Nancy M., Michael T. Goodrich, and Edgar A. Ramos. 2000. “Linear-Time Triangulation of a Simple Polygon Made Easier via Randomization.” In \textit{Proceedings of the 16th Annual Symposium on Computational Geometry}, 201–212. https://doi.org/10.1145/336154.336206.

    \bibitem{Seidel1991}
    Seidel, Raimund. 1991. “A Simple and Fast Incremental Randomized Algorithm for Computing Trapezoidal Decompositions and for Triangulating Polygons.” \textit{Computational Geometry}, 1(1): 51–64. https://doi.org/10.1016/0925-7721(91)90012-4.
\end{thebibliography}

\end{document}